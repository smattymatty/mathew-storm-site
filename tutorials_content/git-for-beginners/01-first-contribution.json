[
  {
    "question-id": "foundational-benefit-of-tracking-versions",
    "question": "Imagine you are working on an important document. What is a key benefit of having a system that can track different versions of your work over time?",
    "answer_a": "It makes the final version of your project much larger in file size.",
    "answer_b": "It allows you to go back to an earlier stable version if you make a mistake.",
    "answer_c": "It automatically shares every version with everyone on the internet.",
    "answer_d": "It prevents anyone else from ever seeing your project.",
    "correct_answer": "b",
    "difficulty": "foundational",
    "tags": ["git", "version-control", "foundational", "problem-solving"],
    "title-id": "01-first-contribution"
  },
  {
    "question-id": "foundational-problem-in-team-collaboration",
    "question": "When several people try to work together on the same set of project files, what is a common problem they might encounter without a good system like Git?",
    "answer_a": "The files might spontaneously organize themselves perfectly.",
    "answer_b": "Team members might accidentally overwrite each other's work or struggle to combine different changes.",
    "answer_c": "The computer usually stops them from saving the file if more than one person has it open.",
    "answer_d": "The project's file size becomes too small to be useful.",
    "correct_answer": "b",
    "difficulty": "foundational",
    "tags": ["git", "collaboration", "foundational", "problem-solving"],
    "title-id": "01-first-contribution"
  },
  {
    "question-id": "foundational-motivation-for-learning-git-github",
    "question": "What is a primary reason a developer would be motivated to learn tools like Git and GitHub?",
    "answer_a": "To learn how to design more visually appealing websites.",
    "answer_b": "To better manage project changes and collaborate effectively with a team.",
    "answer_c": "To become an expert in troubleshooting computer hardware.",
    "answer_d": "To significantly increase their typing speed.",
    "correct_answer": "b",
    "difficulty": "foundational",
    "tags": ["git", "github", "foundational", "motivation"],
    "title-id": "01-first-contribution"
  },
  {
    "question-id": "easy-git-config-identity-purpose",
    "question": "What is the main reason for running the `git config --global user.name` and `user.email` commands?",
    "answer_a": "To set the color scheme of the Git command-line interface.",
    "answer_b": "To log in to your GitHub account from the terminal.",
    "answer_c": "To tell Git who you are, so it can correctly attribute your work on every commit you make.",
    "answer_d": "To change the default text editor that Git uses for commit messages.",
    "correct_answer": "c",
    "difficulty": "easy",
    "tags": ["git", "github", "commit"],
    "title-id": "01-first-contribution"
  },
  {
    "question-id": "easy-git-basics-commit-definition",
    "question": "What is a 'Commit' in Git?",
    "answer_a": "A command that connects your computer to GitHub",
    "answer_b": "A saved snapshot of your changes to the project files",
    "answer_c": "A type of open source project license",
    "answer_d": "A discussion thread about a bug on GitHub",
    "correct_answer": "b",
    "difficulty": "easy",
    "tags": ["git", "commit"],
    "title-id": "01-first-contribution"
  },
  {
    "question-id": "easy-github-workflow-first-step-fork",
    "question": "The tutorial outlines the 'Standard GitHub steps' for contributing. What is the very first step in this workflow?",
    "answer_a": "Clone the project directly to your computer",
    "answer_b": "Fork the project to make a personal copy on GitHub",
    "answer_c": "Immediately create a Pull Request with your ideas",
    "answer_d": "Email the project owner to ask for permission",
    "correct_answer": "b",
    "difficulty": "easy",
    "tags": ["git", "github", "workflow", "fork"],
    "title-id": "01-first-contribution"
  },
  {
    "question-id": "medium-git-upstream-remote-purpose",
    "question": "After cloning your fork, you add the original project's repository as a remote named 'upstream'. What is the primary benefit of this step?",
    "answer_a": "It automatically merges your changes into the original project without a Pull Request.",
    "answer_b": "It allows you to easily fetch updates from the original project to keep your branch synchronized, helping to avoid merge conflicts later.",
    "answer_c": "It grants the original project's maintainers direct write access to your local files.",
    "answer_d": "It is the only way to be able to push any changes to your own fork on GitHub.",
    "correct_answer": "b",
    "difficulty": "medium",
    "tags": ["git", "github", "workflow", "remote", "best-practices"],
    "title-id": "01-first-contribution"
  },
  {
    "question-id": "medium-git-staging-area-advantage",
    "question": "What is the key advantage of using Git's 'staging area' (with the `git add` command) before creating a commit?",
    "answer_a": "It automatically runs tests on your code to ensure it's bug-free before committing.",
    "answer_b": "It allows you to build focused, logical commits by selecting only the specific changes that belong together for a single snapshot.",
    "answer_c": "It bypasses the need for a commit message, speeding up the development process.",
    "answer_d": "It directly pushes your staged changes to the remote repository, combining two steps in one.",
    "correct_answer": "b",
    "difficulty": "medium",
    "tags": ["git", "workflow", "staging", "commit", "best-practices"],
    "title-id": "01-first-contribution"
  },
  {
    "question-id": "medium-github-pr-update-workflow",
    "question": "If a maintainer reviews your Pull Request and requests changes, what is the standard workflow to address the feedback?",
    "answer_a": "Close the current Pull Request and open a brand new one with the updated code.",
    "answer_b": "Make the changes on your local feature branch, create new commits, and push them to the same branch on your fork. The PR will update automatically.",
    "answer_c": "Argue that the changes are not needed and wait for the maintainer to merge the PR as-is.",
    "answer_d": "Create a separate branch named 'fixes' and ask the maintainer to merge it into your PR.",
    "correct_answer": "b",
    "difficulty": "medium",
    "tags": [
      "git",
      "github",
      "workflow",
      "pull-request",
      "collaboration",
      "code-review"
    ],
    "title-id": "01-first-contribution"
  },
  {
    "question-id": "hard-git-commit-amend-pushed-pr-workflow",
    "question": "In the FAQ, a workflow is described for fixing a mistake in your last commit after it's already been pushed to your Pull Request. This involves `git commit --amend` followed by a force push. Why is this combined action necessary and what is its result on the PR?",
    "answer_a": "Amending creates a new commit, and force push adds it to the PR, so the PR will show both the original and the fixed commit.",
    "answer_b": "`git commit --amend` alters the latest commit, and the subsequent `git push --force` is required because this rewritten history has diverged from the remote branch. The result is that the PR is updated to show only the single, corrected commit.",
    "answer_c": "The `--amend` flag automatically notifies GitHub to expect a force push, which simply updates the commit message on the existing commit without changing its history.",
    "answer_d": "This workflow is incorrect; the FAQ states you must create a new commit with the fix and use a regular `git push`.",
    "correct_answer": "b",
    "difficulty": "hard",
    "tags": ["git", "github", "workflow", "pull-request", "commit"],
    "title-id": "01-first-contribution"
  },
  {
    "question-id": "hard-git-accidental-commit-on-main-recovery-workflow",
    "question": "Imagine a scenario where a developer accidentally makes commits on their local `main` branch. It suggests a recovery process starting with `git checkout -b my-intended-feature-branch`. What is the critical purpose of this first step?",
    "answer_a": "It pushes the `main` branch to the remote to back up the mistaken commits before they are deleted.",
    "answer_b": "It creates a new branch that preserves the accidental commits, allowing them to be used in a proper Pull Request later, before the original `main` branch is cleaned up.",
    "answer_c": "It's a command that automatically moves the mistaken commits from `main` to a new branch and cleans `main` in one step.",
    "answer_d": "It deletes the commits from `main` and stores them in a temporary stash.",
    "correct_answer": "b",
    "difficulty": "hard",
    "tags": ["git", "workflow", "branch", "commit", "troubleshooting"],
    "title-id": "01-first-contribution"
  },
  {
    "question-id": "hard-git-remote-url-correction-workflow",
    "question": "Imagine you accidentally cloned the original `upstream` repository instead of your `origin` fork. You have since created a feature branch with new commits. What git command correctly repoints your `origin` remote to your fork, allowing you to `push` your new branch there?",
    "answer_a": "`git remote add origin https://github.com/YOUR_USERNAME/YourFork.git`",
    "answer_b": "`git clone https://github.com/YOUR_USERNAME/YourFork.git`",
    "answer_c": "`git remote set-url origin https://github.com/YOUR_USERNAME/YourFork.git`",
    "answer_d": "`git push --set-upstream origin https://github.com/YOUR_USERNAME/YourFork.git`",
    "correct_answer": "c",
    "difficulty": "hard",
    "tags": ["git", "github", "workflow", "remote", "troubleshooting", "fork"],
    "title-id": "01-first-contribution"
  },
  {
    "question-id": "impossible-git-reset-vs-revert-on-shared-branch",
    "question": "A commit in your open Pull Request introduced a bug. This PR branch is public on your fork. Why is `git revert <buggy-commit-hash>` considered a safer method to undo the change than using `git reset --hard <commit-before-bug>` and then force-pushing?",
    "answer_a": "`git reset --hard` is safer for shared history because it results in a cleaner, linear history.",
    "answer_b": "`git revert` creates a new commit that is the inverse of the bad commit, transparently preserving the project's history. This is safe for shared branches, whereas `git reset --hard` erases history, which can cause major issues for anyone who has already fetched that branch.",
    "answer_c": "`git reset --hard` cannot be used on commits that have already been pushed to a remote repository.",
    "answer_d": "Both commands are identical, but `revert` requires a commit message while `reset` does not.",
    "correct_answer": "b",
    "difficulty": "impossible",
    "tags": ["git", "workflow", "history", "collaboration", "best-practices"],
    "title-id": "01-first-contribution"
  },
  {
    "question-id": "impossible-git-detached-head-implications",
    "question": "You use `git checkout <commit-hash>` to inspect an old version of the project, which puts you in a 'detached HEAD' state. If you make a new commit while in this state, and then switch back to the `main` branch without first creating a new branch for your new commit, what is the status of that new commit?",
    "answer_a": "The new commit is automatically added to the beginning of the `main` branch's history.",
    "answer_b": "The new commit does not belong to any branch and becomes 'dangling'. It can be lost permanently after Git's next garbage collection cycle if you don't find its hash and attach a branch to it.",
    "answer_c": "Git prevents you from making any new commits while in a 'detached HEAD' state to avoid this situation.",
    "answer_d": "The new commit is automatically pushed to a special 'detached' branch on your remote repository.",
    "correct_answer": "b",
    "difficulty": "impossible",
    "tags": ["git", "workflow", "history", "commit"],
    "title-id": "01-first-contribution"
  },
  {
    "question-id": "impossible-git-interactive-rebase-autosquash",
    "question": "To clean up your branch's history before creating a PR, you create several small fixup commits using `git commit --fixup=<target-commit-hash>`. What is the primary purpose of the `--autosquash` flag when you later run `git rebase -i --autosquash main`?",
    "answer_a": "It automatically merges all commits into a single commit without opening the interactive editor.",
    "answer_b": "It automatically reorders the 'fixup!' commits in the interactive TODO list to be right after their target commits and marks them for squashing, saving you from having to do it manually.",
    "answer_c": "It's a deprecated flag that performs the same action as a standard interactive rebase.",
    "answer_d": "It deletes all commits marked with 'fixup!' instead of merging them into their targets.",
    "correct_answer": "b",
    "difficulty": "impossible",
    "tags": [
      "git",
      "workflow",
      "rebase",
      "history",
      "best-practices",
      "commit"
    ],
    "title-id": "01-first-contribution"
  }
]
