[
  {
    "question-id": "pre-assessment-text-editor-basic-purpose",
    "question": "What is a 'text editor' (like VS Code, Notepad, or Sublime Text) most commonly used for when working with computers, especially in contexts like programming?",
    "answer_a": "Primarily for watching videos and streaming movies.",
    "answer_b": "For writing, viewing, and editing plain text files, such as source code or configuration files.",
    "answer_c": "Exclusively for creating and editing spreadsheet data.",
    "answer_d": "As a dedicated tool for advanced photo manipulation and graphic design.",
    "correct_answer": "b",
    "difficulty": "foundational",
    "tags": ["general-knowledge", "tools", "text-editor", "pre-assessment", "software-basics"],
    "title-id": "01-first-contribution"
  },
  {
    "question-id": "pre-assessment-value-of-tracking-changes",
    "question": "Imagine you are working on an important document or a creative project. What is a key benefit of having a system that can track different versions of your work over time?",
    "answer_a": "It makes the final version of your project much larger in file size.",
    "answer_b": "It allows you to revert to a previous stable state if you make a mistake or want to see how something looked earlier.",
    "answer_c": "It automatically shares every version with everyone on the internet.",
    "answer_d": "It prevents anyone else from ever seeing your project.",
    "correct_answer": "b",
    "difficulty": "foundational",
    "tags": ["general-knowledge", "version-control-concept", "problem-awareness", "pre-assessment", "project-management"],
    "title-id": "01-first-contribution"
  },
  {
    "question-id": "pre-assessment-challenges-in-team-collaboration-on-files",
    "question": "When several people try to work together on the same set of digital files (e.g., code for a project, a group report), what is a common problem they might encounter without a good system in place?",
    "answer_a": "The files might spontaneously duplicate themselves too many times.",
    "answer_b": "Team members might accidentally overwrite each other's contributions or struggle to merge different changes made at the same time.",
    "answer_c": "The computer usually stops them from saving the file if more than one person has it open.",
    "answer_d": "The files automatically organize themselves perfectly without any effort.",
    "correct_answer": "b",
    "difficulty": "foundational",
    "tags": ["general-knowledge", "collaboration", "teamwork", "problem-awareness", "pre-assessment"],
    "title-id": "01-first-contribution"
  },
  {
    "question-id": "pre-assessment-general-motivation-for-learning-git-github",
    "question": "Which of the following best describes a primary reason why someone, especially in tech or software development, would be motivated to learn tools like Git and GitHub?",
    "answer_a": "To learn how to design more visually appealing user interfaces for websites.",
    "answer_b": "To gain skills for better managing software projects, tracking code changes effectively, and collaborating with other developers.",
    "answer_c": "To become an expert in troubleshooting computer hardware issues.",
    "answer_d": "To significantly increase their typing speed for general computer use.",
    "correct_answer": "b",
    "difficulty": "foundational",
    "tags": ["general-knowledge", "motivation", "git", "github", "pre-assessment", "software-development"],
    "title-id": "01-first-contribution"
  },
  {
    "question-id": "pre-assessment-basic-understanding-of-open-source-software",
    "question": "What is a general characteristic of 'open source' software?",
    "answer_a": "It means the software is always very simple and has limited features.",
    "answer_b": "It implies that the software's underlying source code is made publicly available, allowing people to view, often modify, and distribute it (usually under specific licenses).",
    "answer_c": "It refers to software that can only be opened and used on specific, proprietary hardware.",
    "answer_d": "It means the software is guaranteed to be 100% free of any bugs or security vulnerabilities.",
    "correct_answer": "b",
    "difficulty": "foundational",
    "tags": ["general-knowledge", "open-source", "software-concepts", "pre-assessment", "licensing"],
    "title-id": "01-first-contribution"
  },
  {
    "question-id": "tutorial-requirements-github-account",
    "question": "Which of the following is a key requirement mentioned for starting your First Contribution?",
    "answer_a": "A fast internet connection",
    "answer_b": "A GitHub account",
    "answer_c": "A powerful computer",
    "answer_d": "At least 5 years of coding experience",
    "correct_answer": "b",
    "difficulty": "easy",
    "tags": ["github", "requirements", "beginner"],
    "title-id": "01-first-contribution"
  },
  {
    "question-id": "git-basics-commit-definition",
    "question": "In Git, what is a 'Commit'?",
    "answer_a": "A command to connect to GitHub",
    "answer_b": "A saved snapshot of your changes",
    "answer_c": "A type of project license",
    "answer_d": "A discussion thread about a bug",
    "correct_answer": "b",
    "difficulty": "easy",
    "tags": ["git", "commit", "basics"],
    "title-id": "01-first-contribution"
  },
  {
    "question-id": "github-workflow-fork-step",
    "question": "What is the first step in the standard GitHub workflow when you want to contribute to someone else's project that you don't have direct write access to?",
    "answer_a": "Clone the project directly to your computer",
    "answer_b": "Immediately create a Pull Request with your ideas",
    "answer_c": "Fork the project to your personal GitHub account",
    "answer_d": "Email the project owner your intended changes",
    "correct_answer": "c",
    "difficulty": "easy",
    "tags": ["github", "workflow", "fork", "contributing"],
    "title-id": "01-first-contribution"
  },
  {
    "question-id": "git-commands-cross-platform-consistency",
    "question": "Once Git is installed, are the core Git commands (e.g., `git commit`, `git branch`) fundamentally different depending on whether you are using Windows, Mac, or Linux?",
    "answer_a": "Yes, each operating system requires a completely unique set of Git commands.",
    "answer_b": "No, the core Git commands are identical across these platforms.",
    "answer_c": "Only `git push` and `git pull` are the same; others vary significantly.",
    "answer_d": "The commands are similar, but all the flags and options change for each OS.",
    "correct_answer": "b",
    "difficulty": "easy",
    "tags": ["git", "commands", "os", "basics"],
    "title-id": "01-first-contribution"
  },
  {
    "question-id": "git-config-set-global-username",
    "question": "Which Git command is used to set your global username that will be associated with your commits?",
    "answer_a": "git set user --name \"Your Name\"",
    "answer_b": "git config --global user.name \"Your Name\"",
    "answer_c": "git username --global \"Your Name\"",
    "answer_d": "git global config user.name = \"Your Name\"",
    "correct_answer": "b",
    "difficulty": "easy",
    "tags": ["git", "config", "commands", "setup", "identity"],
    "title-id": "01-first-contribution"
  },
  {
    "question-id": "git-branching-avoid-main-for-new-work",
    "question": "When starting to work on a new feature or bug fix, is it generally recommended to make your changes directly on the `main` (or `master`) branch?",
    "answer_a": "Yes, all new code should always go directly into the `main` branch.",
    "answer_b": "No, you should create a new branch for your changes to keep them isolated.",
    "answer_c": "It only matters for very large changes; small changes can go to `main`.",
    "answer_d": "Yes, but only if you are the sole contributor to the project.",
    "correct_answer": "b",
    "difficulty": "easy",
    "tags": ["git", "branch", "workflow", "best-practices"],
    "title-id": "01-first-contribution"
  },
  {
    "question-id": "git-staging-git-add-dot-purpose",
    "question": "In Git, what is the primary purpose of the `git add .` command?",
    "answer_a": "It adds a detailed comment to your most recent commit.",
    "answer_b": "It stages all changed files in the current directory and its subdirectories for the next commit.",
    "answer_c": "It archives your project and adds it to a remote server.",
    "answer_d": "It pushes all your committed local changes to the GitHub repository.",
    "correct_answer": "b",
    "difficulty": "easy",
    "tags": ["git", "staging", "commands", "git add"],
    "title-id": "01-first-contribution"
  },
  {
    "question-id": "github-pull-request-definition",
    "question": "What is a 'Pull Request (PR)' in the context of GitHub?",
    "answer_a": "A formal request to an administrator to pull your personal data from GitHub.",
    "answer_b": "A formal proposal to merge changes from one branch (e.g., your feature branch) into another branch (e.g., the main project's branch).",
    "answer_c": "A Git command that automatically fixes (pulls out) errors in your code.",
    "answer_d": "A notification that your repository is being pulled down in popularity.",
    "correct_answer": "b",
    "difficulty": "easy",
    "tags": ["github", "pull request", "workflow", "contributing", "collaboration"],
    "title-id": "01-first-contribution"
  },
  {
    "question-id": "github-auth-pat-vs-ssh-security-convenience",
    "question": "When authenticating with GitHub for frequent use, which method is generally recommended for a good balance of security and convenience, involving the setup of cryptographic keys on your computer?",
    "answer_a": "Using HTTPS with a Personal Access Token (PAT) for every single push operation.",
    "answer_b": "Saving your GitHub username and password directly in Git configuration files.",
    "answer_c": "Setting up and using SSH Keys.",
    "answer_d": "Authenticating solely through the GitHub CLI's web login each time.",
    "correct_answer": "c",
    "difficulty": "medium",
    "tags": ["github", "authentication", "ssh", "pat", "security", "git"],
    "title-id": "01-first-contribution"
  },
  {
    "question-id": "git-cloning-upstream-remote-purpose-synchronization",
    "question": "After cloning your forked repository to your local machine, what is the primary benefit of adding the original project's repository as a remote (commonly named 'upstream')?",
    "answer_a": "It automatically merges your changes into the original project without a Pull Request.",
    "answer_b": "It allows you to easily fetch updates from the original project to keep your main branch synchronized, helping to avoid merge conflicts later.",
    "answer_c": "It grants the original project maintainers direct write access to your local cloned repository.",
    "answer_d": "It's a necessary step to be able to push any changes to your own fork on GitHub.",
    "correct_answer": "b",
    "difficulty": "medium",
    "tags": ["git", "github", "cloning", "forking", "remote", "upstream", "workflow"],
    "title-id": "01-first-contribution"
  },
  {
    "question-id": "git-branching-naming-clarity-and-isolation",
    "question": "Why is creating descriptively named branches (e.g., `fix/login-button-bug` or `feature/user-profile-page`) considered a vital best practice in Git workflows?",
    "answer_a": "Because Git's performance significantly improves with longer, more descriptive branch names.",
    "answer_b": "To ensure that the branch name is unique across all repositories on GitHub.",
    "answer_c": "It clearly communicates the purpose of the work being done on that branch and helps keep those changes isolated from the main codebase until they are ready and reviewed.",
    "answer_d": "This naming convention automatically links the branch to project management tools.",
    "correct_answer": "c",
    "difficulty": "medium",
    "tags": ["git", "branch", "best-practices", "workflow", "naming-conventions"],
    "title-id": "01-first-contribution"
  },
  {
    "question-id": "git-staging-area-selective-commits-benefit",
    "question": "Git's two-step commit process involves a 'staging area' (using `git add`). What is a significant advantage of this staging step before making a commit?",
    "answer_a": "It automatically runs tests on your code to ensure it's bug-free before committing.",
    "answer_b": "It allows you to selectively choose which of your modifications to include in the next commit, enabling the creation of focused, logical commits even if you've worked on multiple unrelated things.",
    "answer_c": "It bypasses the need for a commit message, speeding up the development process.",
    "answer_d": "It directly pushes your staged changes to the remote repository, combining `add` and `push` into one step.",
    "correct_answer": "b",
    "difficulty": "medium",
    "tags": ["git", "staging", "commit", "workflow", "git add", "best-practices"],
    "title-id": "01-first-contribution"
  },
  {
    "question-id": "git-commit-best-practices-atomic-focused-changes",
    "question": "What is the main rationale behind the best practice of making small, focused commits, where each commit ideally represents a single logical change?",
    "answer_a": "To increase the total number of commits, which is a primary metric for developer productivity.",
    "answer_b": "To make the commit history more difficult for others to follow, enhancing job security.",
    "answer_c": "It simplifies understanding the project's history, makes code reviews more effective, allows for easier reverting of specific changes if something goes wrong, and aids in pinpointing when bugs were introduced.",
    "answer_d": "Because Git repositories have a strict limit on the size of individual commits, forcing them to be small.",
    "correct_answer": "c",
    "difficulty": "medium",
    "tags": ["git", "commit", "best-practices", "workflow", "code-review"],
    "title-id": "01-first-contribution"
  },
  {
    "question-id": "git-push-set-upstream-flag-u-purpose",
    "question": "When you push a new local branch to your remote repository for the first time using `git push -u origin your-branch-name`, what does the `-u` (or `--set-upstream`) flag primarily accomplish?",
    "answer_a": "It 'undoes' the most recent commit on that branch before pushing.",
    "answer_b": "It forces the push even if there are conflicts with the remote branch.",
    "answer_c": "It establishes a tracking relationship between your local branch and the newly created remote branch, so future `git push` and `git pull` commands from that branch will automatically know which remote branch to interact with.",
    "answer_d": "It makes the branch 'unique' by adding a special identifier to its name on the remote.",
    "correct_answer": "c",
    "difficulty": "medium",
    "tags": ["git", "push", "remote", "branch", "upstream-tracking", "commands"],
    "title-id": "01-first-contribution"
  },
  {
    "question-id": "vscode-extensions-gitlens-vs-gitgraph-core-distinction",
    "question": "Considering VS Code extensions for Git, what is a key functional distinction between GitLens and Git Graph in how they help you understand your repository?",
    "answer_a": "GitLens is primarily for creating new branches, while Git Graph is for merging them.",
    "answer_b": "GitLens excels at providing deep, line-level code authorship insights (blame) and detailed commit exploration, whereas Git Graph focuses on offering a clear visual representation of the repository's branch structure and commit history flow.",
    "answer_c": "GitLens is a paid extension, while Git Graph is free and open-source.",
    "answer_d": "GitLens is used for interacting with GitHub Pull Requests, while Git Graph is for managing local stashes.",
    "correct_answer": "b",
    "difficulty": "medium",
    "tags": ["vscode", "extensions", "gitlens", "gitgraph", "git", "visualization", "code-authorship"],
    "title-id": "01-first-contribution"
  },
  {
    "question-id": "git-updating-pr-rebase-vs-merge-history-implications",
    "question": "When incorporating recent changes from an `upstream/main` branch into your feature branch for a Pull Request, why is `git rebase upstream/main` often preferred by projects over `git merge upstream/main` for the feature branch?",
    "answer_a": "Merging creates a simpler, single commit on the feature branch, making it easier to review.",
    "answer_b": "Rebasing is a non-destructive operation that never changes existing commit hashes.",
    "answer_c": "Rebasing rewrites the feature branch's history to appear as if its commits were made sequentially after the latest `upstream/main` changes, resulting in a cleaner, linear project history when the PR is eventually merged.",
    "answer_d": "Merging automatically resolves all potential conflicts, whereas rebasing requires manual intervention for every conflict.",
    "correct_answer": "c",
    "difficulty": "hard",
    "tags": ["git", "pull request", "rebase", "merge", "workflow", "history", "best-practices"],
    "title-id": "01-first-contribution"
  },
  {
    "question-id": "git-merge-conflicts-during-rebase-resolution-workflow",
    "question": "If you encounter merge conflicts while executing `git rebase upstream/main` on your feature branch, what is the correct sequence of actions after Git pauses and informs you of the conflicting files?",
    "answer_a": "Immediately run `git rebase --skip` to ignore the problematic commit and continue.",
    "answer_b": "Manually edit the conflicted files to your desired state, then use `git commit -a` to save the resolution, and finally run `git rebase --continue`.",
    "answer_c": "Manually edit the conflicted files, use `git add <resolved-file-paths>` to mark them as resolved, and then run `git rebase --continue`. A separate commit is not made at this stage of conflict resolution during a rebase.",
    "answer_d": "Delete your local branch using `git branch -D your-branch` and re-clone the repository to start fresh, as conflicts during rebase are usually unrecoverable.",
    "correct_answer": "c",
    "difficulty": "hard",
    "tags": ["git", "merge conflicts", "rebase", "workflow", "commands", "conflict-resolution"],
    "title-id": "01-first-contribution"
  },
  {
    "question-id": "github-pr-description-automated-issue-closing-keywords",
    "question": "In a GitHub Pull Request description, what specific effect do keywords like `Fixes #123`, `Closes #issue-number`, or `Resolves org/repo#456` have when the PR is eventually merged into the default branch?",
    "answer_a": "They only create hyperlinks to the mentioned issues and notify the issue subscribers of the PR.",
    "answer_b": "They assign the PR author as the new owner of the mentioned issues.",
    "answer_c": "They link the PR to the issues for tracking, and GitHub automatically closes the referenced issues upon the PR's merge.",
    "answer_d": "They add a 'Fixed by PR' label to the issues but require manual closing by a maintainer after verification.",
    "correct_answer": "c",
    "difficulty": "hard",
    "tags": ["github", "pull request", "issues", "automation", "workflow", "integration"],
    "title-id": "01-first-contribution"
  },
  {
    "question-id": "git-commands-reset-hard-vs-revert-history-safety",
    "question": "Considering commands for undoing changes like `git reset --hard <commit>` and `git revert <commit>`, what is a critical difference in how they affect project history, especially when dealing with commits already pushed and shared with others?",
    "answer_a": "`git reset --hard` is safer for shared history as it just moves the HEAD pointer, while `git revert` deletes commits.",
    "answer_b": "`git revert` creates a new commit that inverses the changes of a previous commit, preserving history, making it safer for shared branches. `git reset --hard` discards commits and rewrites history, which is dangerous for shared branches.",
    "answer_c": "Both commands rewrite history; `git reset --hard` is for undoing staged changes, and `git revert` is for undoing committed changes.",
    "answer_d": "`git revert` can only undo the very last commit, while `git reset --hard` can undo multiple commits.",
    "correct_answer": "b",
    "difficulty": "hard",
    "tags": ["git", "commands", "reset", "revert", "history", "shared-branches", "safety"],
    "title-id": "01-first-contribution"
  },
  {
    "question-id": "git-fork-maintenance-rebasing-new-feature-branches-advantage",
    "question": "Why is it crucial to regularly sync your fork's `main` branch with the `upstream/main` and then start new feature branches from this updated `main` branch, particularly in active projects?",
    "answer_a": "To ensure your fork uses unique commit IDs not present in the upstream repository, preventing ID clashes.",
    "answer_b": "This practice primarily serves to increase your contribution count on GitHub by creating more sync commits.",
    "answer_c": "Starting new work from the latest upstream `main` ensures your changes are built upon the most current project state, which significantly reduces the likelihood and complexity of merge conflicts when you eventually create a Pull Request and makes your contribution more relevant.",
    "answer_d": "GitHub's terms of service require forks to be synchronized with their upstream at least weekly to remain active.",
    "correct_answer": "c",
    "difficulty": "hard",
    "tags": ["git", "github", "fork", "upstream", "syncing", "workflow", "best-practices", "merge-conflicts"],
    "title-id": "01-first-contribution"
  },
  {
    "question-id": "git-updating-pr-necessity-of-force-push-after-rebase",
    "question": "When you rebase your local feature branch (which has already been pushed and has an open PR) with changes from `upstream/main`, why is `git push --force` (or `git push -f`) typically required to update the branch on your remote fork?",
    "answer_a": "The `--force` flag is simply an alias for `--update`, ensuring all remote tracking information is refreshed.",
    "answer_b": "Rebasing alters the commit history of your local feature branch (e.g., changing commit SHAs and their order). This rewritten history diverges from the history on your remote fork's version of the branch, so a regular `git push` is rejected. Force push overwrites the remote branch with your modified local branch.",
    "answer_c": "GitHub requires force pushes for all PR updates to signify that the changes are critical and need immediate attention from maintainers.",
    "answer_d": "It's a security measure to confirm you own the branch, similar to a two-factor authentication for pushes after a rebase.",
    "correct_answer": "b",
    "difficulty": "hard",
    "tags": ["git", "pull request", "rebase", "force-push", "history", "workflow", "remote"],
    "title-id": "01-first-contribution"
  },
  {
    "question-id": "git-internals-object-model-tree-blob-relationship",
    "question": "Within Git's low-level object model, if you were to inspect the raw content of a 'tree' object (e.g., using `git cat-file -p <tree_sha1>`), what information does it directly contain, and how does it reference file content?",
    "answer_a": "It contains the full diff of changes for a directory, pointing to other tree objects for sub-directories and blob objects for parent directory content.",
    "answer_b": "It stores a list of filenames within that directory, their permissions, and for each file, a SHA-1 hash pointing to a 'blob' object that holds the actual file content. For subdirectories, it points to other 'tree' objects.",
    "answer_c": "It's a metadata object containing the commit message, author, committer, and a pointer to a single 'blob' representing the entire project snapshot.",
    "answer_d": "It primarily stores a compressed archive of all files in a directory, with 'blob' objects acting as an index to this archive.",
    "correct_answer": "b",
    "difficulty": "impossible",
    "tags": ["git", "internals", "object-model", "tree-object", "blob-object", "advanced"],
    "title-id": "01-first-contribution"
  },
  {
    "question-id": "git-advanced-rebase-interactive-autosquash-fixup-mechanism",
    "question": "When using `git rebase -i --autosquash <target-branch>`, how does Git identify which 'fixup!' or 'squash!' commits should be automatically reordered and marked for squashing with their corresponding target commits in the interactive TODO list?",
    "answer_a": "It relies on the `fixup!` or `squash!` commits having identical commit messages (excluding the prefix) to their target commits.",
    "answer_b": "The target commit must have a special note in its commit message (e.g., `Target-for-fixup: <fixup-commit-sha>`).",
    "answer_c": "It matches `fixup!` or `squash!` commits if their commit message's subject line (after the prefix) refers to the subject line of an earlier commit in the rebase set, or if they are created using `git commit --fixup=<commit-sha>` or `git commit --squash=<commit-sha>` which embeds the target commit's SHA.",
    "answer_d": "`--autosquash` is a deprecated feature and no longer reliably determines commit relationships; manual reordering is always required.",
    "correct_answer": "c",
    "difficulty": "impossible",
    "tags": ["git", "rebase", "interactive-rebase", "autosquash", "fixup", "advanced-workflow"],
    "title-id": "01-first-contribution"
  },
  {
    "question-id": "git-merge-conflict-style-diff3-common-ancestor-information",
    "question": "If a user configures `merge.conflictStyle` to `diff3` in their Git configuration, what additional piece of information is embedded within the conflict markers (e.g., `<<<<<<<`, `=======`, `>>>>>>>`) during a merge conflict, compared to the default style?",
    "answer_a": "The email addresses of the authors of the conflicting commits.",
    "answer_b": "A proposed, automatically generated resolution for the conflict based on Git's heuristics.",
    "answer_c": "A section, typically marked with `|||||||`, showing the original version of the conflicting lines from the common ancestor of the two merging branches.",
    "answer_d": "A timestamp indicating when each side of the conflicting change was originally committed.",
    "correct_answer": "c",
    "difficulty": "impossible",
    "tags": ["git", "merge-conflicts", "diff3", "configuration", "advanced-diff", "merge-strategies"],
    "title-id": "01-first-contribution"
  },
  {
    "question-id": "git-plumbing-vs-porcelain-dangling-object-recovery-after-gc",
    "question": "Imagine a scenario where a local branch was accidentally deleted, and subsequently `git gc` (garbage collection) was run after the default reflog expiry period for unreachable objects (e.g., >90 days for unreachable, >30 days for `gc.pruneExpire`). Which statement best describes the challenge and potential approach to recovering commits from that deleted branch?",
    "answer_a": "Recovery is impossible; `git gc` permanently deletes all unreferenced objects immediately, regardless of reflogs.",
    "answer_b": "Porcelain commands like `git reflog show <deleted-branch-name>` would easily find the commits, as reflogs are kept indefinitely by default.",
    "answer_c": "Recovery would likely involve using plumbing commands like `git fsck --full --no-reflogs --unreachable` to find 'dangling' commit objects. It's significantly harder because `git gc` may have pruned (permanently deleted) these objects if they were truly unreachable and their reflog entries had expired, or if `gc.reflogExpireUnreachable` was set aggressively.",
    "answer_d": "You must contact GitHub support; only they have the tools to recover objects after local garbage collection if the project was ever pushed.",
    "correct_answer": "c",
    "difficulty": "impossible",
    "tags": ["git", "plumbing", "porcelain", "garbage-collection", "reflog", "data-recovery", "advanced-internals", "fsck"],
    "title-id": "01-first-contribution"
  },
  {
    "question-id": "github-actions-reusable-workflow-matrix-strategy-inheritance",
    "question": "When calling a reusable workflow in GitHub Actions (`uses: ./.github/workflows/reusable.yml`), if the reusable workflow (`reusable.yml`) defines a matrix strategy, and the caller workflow *also* defines a matrix strategy, how do these strategies interact for the jobs within the reusable workflow?",
    "answer_a": "The caller's matrix strategy completely overrides the reusable workflow's matrix strategy.",
    "answer_b": "The reusable workflow's matrix strategy is ignored; only the caller's matrix applies to the jobs it defines directly, not the jobs within the reusable workflow.",
    "answer_c": "The two matrix strategies are combined multiplicatively, creating a job run for every possible combination of matrix values from both the caller and the reusable workflow for the jobs within the reusable workflow.",
    "answer_d": "This scenario is not allowed by GitHub Actions; a reusable workflow cannot have its own matrix strategy if the calling workflow also uses one, leading to a validation error.",
    "correct_answer": "d",
    "difficulty": "impossible",
    "tags": ["github-actions", "reusable-workflows", "matrix-strategy", "ci-cd", "advanced-workflow", "yaml"],
    "title-id": "01-first-contribution"
  },
  {
    "question-id": "pre-assessment-value-of-code-review-collaboration",
    "question": "When working on a software project with other people, why is it generally considered a good practice to have someone else review your code changes before they are officially added to the main project?",
    "answer_a": "It primarily serves to slow down the development process and add bureaucracy.",
    "answer_b": "It helps to identify potential mistakes, suggest improvements, share knowledge, and ensure the changes meet the project's quality standards and goals.",
    "answer_c": "It's only necessary if the person who wrote the code is very inexperienced.",
    "answer_d": "The main reason is to give senior developers a chance to criticize junior developers' work.",
    "correct_answer": "b",
    "difficulty": "foundational",
    "tags": ["collaboration", "code-review", "quality-assurance", "teamwork", "pre-assessment"],
    "title-id": "01-first-contribution"
  },
  {
    "question-id": "github-pull-request-fundamental-purpose",
    "question": "After you have pushed your committed changes on a new branch to your fork on GitHub, what is the fundamental purpose of creating a Pull Request (PR)?",
    "answer_a": "To automatically merge your branch into the original project's main branch without any checks.",
    "answer_b": "To notify your followers on GitHub that you have new code they can download.",
    "answer_c": "To formally propose your changes to the original project, allowing for discussion, code review by maintainers, and eventual merging if approved.",
    "answer_d": "To create a private backup of your branch that only you can see.",
    "correct_answer": "c",
    "difficulty": "easy",
    "tags": ["github", "pull-request", "workflow", "collaboration", "contributing"],
    "title-id": "01-first-contribution"
  },
  {
    "question-id": "github-pr-addressing-review-feedback-workflow",
    "question": "If a maintainer reviews your Pull Request and requests specific changes to your code, what is the standard workflow to address this feedback?",
    "answer_a": "Delete your current Pull Request and open a brand new one with all the changes from scratch.",
    "answer_b": "Make the requested code changes on your local feature branch, add new commits for these changes, and then push these new commits to the same branch on your remote fork. The Pull Request will update automatically.",
    "answer_c": "Reply to the review comments explaining why the changes are not needed and wait for the maintainer to merge it anyway.",
    "answer_d": "Create a separate branch for the review changes and ask the maintainer to manually combine it with your original PR branch.",
    "correct_answer": "b",
    "difficulty": "medium",
    "tags": ["github", "pull-request", "code-review", "workflow", "updating-pr", "collaboration"],
    "title-id": "01-first-contribution"
  },
  {
    "question-id": "git-pr-update-force-push-with-lease-advantage",
    "question": "When updating a remote branch for an open Pull Request after rebasing it locally (which rewrites history), `git push --force` is often used. What is a key advantage of using `git push --force-with-lease` instead of a plain `git push --force`?",
    "answer_a": "`--force-with-lease` is significantly faster as it skips all remote checks.",
    "answer_b": "`--force-with-lease` automatically creates a backup tag of the remote branch before overwriting it.",
    "answer_c": "`--force-with-lease` is a safer option because it will only update the remote branch if its current state matches what your local Git expects (i.e., no one else has pushed to it since your last fetch). This helps prevent accidentally overwriting someone else's recent work on that same remote branch.",
    "answer_d": "`--force-with-lease` sends an email notification to all collaborators that a force push is about to occur.",
    "correct_answer": "c",
    "difficulty": "hard",
    "tags": ["git", "push", "force-push", "force-with-lease", "rebase", "collaboration", "branch-safety", "advanced-git"],
    "title-id": "01-first-contribution"
  },
  {
    "question-id": "git-stash-interaction-with-index-and-untracked-files",
    "question": "Consider a scenario where you have staged some changes, have other unstaged modifications to tracked files, and also new untracked (but not ignored) files. If you execute `git stash push --include-untracked -m \"Complex stash\"` and later `git stash apply --index stash@{0}`, what is the most accurate description of the expected state?",
    "answer_a": "Only staged and unstaged changes to tracked files are restored; untracked files are lost, and the index (staging area) is completely cleared.",
    "answer_b": "All changes (staged, unstaged tracked, and the previously untracked files) are restored to the working directory. The staging area is restored to its exact pre-stash state for the tracked files, and the previously untracked files are now tracked and staged.",
    "answer_c": "Staged and unstaged changes to tracked files are restored, and the staging area for these is attempted to be restored. The previously untracked files are restored to the working directory as untracked files. They are not automatically staged by `apply --index`.",
    "answer_d": "`git stash apply --index` cannot handle stashes created with `--include-untracked` and will result in an error, requiring `git stash pop` instead.",
    "correct_answer": "c",
    "difficulty": "impossible",
    "tags": ["git", "stash", "index", "untracked-files", "apply-index", "advanced-commands", "git-internals-behavior"],
    "title-id": "01-first-contribution"
  },
  {
    "question-id": "pre-assessment-learning-new-tech-attitude",
    "question": "When approaching a new technical skill like learning Git and GitHub, which mindset is generally most helpful for success?",
    "answer_a": "Believing you should understand everything perfectly from the very beginning.",
    "answer_b": "Being patient with yourself, expecting a learning curve, and being open to asking questions and making mistakes.",
    "answer_c": "Only trying to learn if someone else can do all the difficult parts for you.",
    "answer_d": "Assuming it will be too complicated to ever understand.",
    "correct_answer": "b",
    "difficulty": "foundational",
    "tags": ["learning", "mindset", "beginner", "pre-assessment", "problem-solving"],
    "title-id": "01-first-contribution"
  },
  {
    "question-id": "git-basics-branch-core-idea",
    "question": "What is the core idea behind using a 'branch' in Git while working on a project?",
    "answer_a": "To permanently delete a part of your project's history.",
    "answer_b": "To create an isolated line of development where you can work on new features or fixes without affecting the main codebase immediately.",
    "answer_c": "To automatically share your code with everyone on your team as you type it.",
    "answer_d": "To create a read-only version of your project.",
    "correct_answer": "b",
    "difficulty": "easy",
    "tags": ["git", "branch", "basics", "workflow", "version-control"],
    "title-id": "01-first-contribution"
  },
  {
    "question-id": "github-workflow-purpose-of-linking-pr-to-issue",
    "question": "In the context of a GitHub Pull Request, what is a key benefit of linking your PR to an existing issue (e.g., using 'Closes #123' in the PR description)?",
    "answer_a": "It automatically assigns you more GitHub achievement badges.",
    "answer_b": "It provides context for your changes, helps track the progress of the issue, and can automatically close the linked issue when the PR is merged.",
    "answer_c": "It prevents anyone else from commenting on the original issue.",
    "answer_d": "It ensures your Pull Request gets merged faster than others.",
    "correct_answer": "b",
    "difficulty": "medium",
    "tags": ["github", "pull-request", "issues", "workflow", "collaboration", "automation"],
    "title-id": "01-first-contribution"
  },
  {
    "question-id": "git-rebase-workflow-vs-merge-workflow-shared-history-consideration",
    "question": "When deciding whether to use `git rebase` versus `git merge` to incorporate changes from a main development branch (e.g., `upstream/main`) into your feature branch, what is a critical consideration regarding shared history?",
    "answer_a": "`git merge` is always preferred as it creates a simpler, single commit point.",
    "answer_b": "`git rebase` should primarily be used on branches that have already been shared with and pulled by other collaborators, as it simplifies their update process.",
    "answer_c": "`git rebase` rewrites the commit history of your feature branch. This is generally acceptable for your own local feature branches before they are merged into a shared public branch, as it can create a cleaner, linear project history. However, rebasing (and force-pushing) shared branches that others are working on can cause significant problems for collaborators.",
    "answer_d": "`git rebase` automatically resolves all merge conflicts, making it superior to `git merge` which requires manual conflict resolution.",
    "correct_answer": "c",
    "difficulty": "hard",
    "tags": ["git", "rebase", "merge", "workflow", "history-rewriting", "collaboration", "best-practices"],
    "title-id": "01-first-contribution"
  },
  {
    "question-id": "git-internals-detached-head-state-implications",
    "question": "If you checkout a specific commit hash directly (e.g., `git checkout <commit_sha>`) rather than a branch name, Git typically puts you in a 'detached HEAD' state. What are the primary implications of making new commits while in this state?",
    "answer_a": "New commits are automatically added to all existing local branches simultaneously.",
    "answer_b": "New commits are created, but they don't belong to any named branch. If you switch to another branch without creating a new branch from this state, these new commits might become 'orphaned' and eventually subject to garbage collection unless you explicitly create a branch to point to them.",
    "answer_c": "Git prevents you from making any new commits in a 'detached HEAD' state to avoid corrupting the repository.",
    "answer_d": "New commits made in a 'detached HEAD' state are immediately pushed to the remote `origin` and a new remote branch is automatically created for them.",
    "correct_answer": "b",
    "difficulty": "impossible",
    "tags": ["git", "detached-head", "checkout", "commit", "internals", "advanced-git", "garbage-collection"],
    "title-id": "01-first-contribution"
  },
  {
    "question-id": "pre-assessment-open-source-contribution-motivation",
    "question": "Which of the following best describes a common motivation for individuals to contribute to open source projects?",
    "answer_a": "To gain exclusive access to secret software features.",
    "answer_b": "To learn new skills, collaborate with others, build a portfolio, and give back to a community or project they find valuable.",
    "answer_c": "To quickly earn a large amount of money.",
    "answer_d": "To ensure that the software can never be used for commercial purposes.",
    "correct_answer": "b",
    "difficulty": "foundational",
    "tags": ["open-source", "motivation", "community", "learning", "pre-assessment"],
    "title-id": "01-first-contribution"
  },
  {
    "question-id": "git-basics-remote-repository-concept",
    "question": "In Git terminology, what is a 'remote' repository?",
    "answer_a": "A backup copy of your Git installation files.",
    "answer_b": "A version of your repository that is hosted on a server elsewhere, like on GitHub, which allows for collaboration and backup.",
    "answer_c": "A special type of branch that cannot be modified.",
    "answer_d": "A Git command used to remove files from your local repository.",
    "correct_answer": "b",
    "difficulty": "easy",
    "tags": ["git", "remote", "repository", "github", "basics", "collaboration"],
    "title-id": "01-first-contribution"
  },
  {
    "question-id": "git-workflow-importance-of-pulling-before-pushing-shared-branch",
    "question": "If you are working on a shared branch (not your own feature branch) with others, why is it generally important to `git pull` (or `git fetch` and `git merge/rebase`) before you `git push` your own new commits?",
    "answer_a": "`git pull` automatically deletes any conflicting files from your local machine.",
    "answer_b": "To incorporate any changes others may have pushed to the shared branch since your last update, resolve any potential merge conflicts locally, and ensure your changes are based on the latest version before pushing.",
    "answer_c": "`git pull` is only needed if you want to change your commit messages before pushing.",
    "answer_d": "It's not important; `git push --force` will always ensure your changes are accepted on the remote.",
    "correct_answer": "b",
    "difficulty": "medium",
    "tags": ["git", "pull", "push", "fetch", "workflow", "collaboration", "shared-branch"],
    "title-id": "01-first-contribution"
  },
  {
    "question-id": "git-commit-amending-pushed-commit-implications",
    "question": "You've made a commit and pushed it to your feature branch on your remote fork (which has an open PR). You then realize you need to make a small correction to that last commit. If you use `git commit --amend` and then `git push`, what will likely happen and why?",
    "answer_a": "The push will succeed, and GitHub will automatically append '(amended)' to your original commit message in the PR.",
    "answer_b": "The push will be rejected because amending a commit rewrites its history (changes its SHA-1). The local and remote branches will have diverged. You would typically need to use `git push --force` or `git push --force-with-lease` to update the remote branch.",
    "answer_c": "`git commit --amend` cannot be used on commits that have already been pushed; Git will show an error.",
    "answer_d": "The push will succeed, but it will create a new, separate commit on the remote branch, leaving the original (now incorrect) commit also visible in the PR history.",
    "correct_answer": "b",
    "difficulty": "hard",
    "tags": ["git", "commit-amend", "push", "force-push", "history-rewriting", "pull-request", "workflow"],
    "title-id": "01-first-contribution"
  },
  {
    "question-id": "git-bisect-purpose-and-basic-mechanism",
    "question": "What is the primary purpose of the `git bisect` command, and how does it generally work to achieve this?",
    "answer_a": "`git bisect` is used to split a large commit into several smaller ones to improve repository performance.",
    "answer_b": "`git bisect` helps you find which commit introduced a bug by performing an automated binary search through the commit history. You tell it a 'good' commit (where the bug didn't exist) and a 'bad' commit (where the bug exists), and Git then checks out commits in between, asking you to identify them as 'good' or 'bad' until the problematic commit is pinpointed.",
    "answer_c": "`git bisect` is a tool for visualizing the two parent commits of a merge commit to understand its history.",
    "answer_d": "`git bisect` automatically identifies and reverts commits that are known to cause common security vulnerabilities.",
    "correct_answer": "b",
    "difficulty": "impossible",
    "tags": ["git", "bisect", "debugging", "commit-history", "advanced-commands", "troubleshooting"],
    "title-id": "01-first-contribution"
  }
]